// api/fun/akinator/index.js
const express = require("express");
const axios = require("axios");
const router = express.Router();
const { v4: uuidv4 } = require('uuid');

// Almacenamiento en memoria para las partidas activas y temporizadores
const partidasActivas = {};
const temporizadoresPartidas = {};

// Configuraci√≥n de categor√≠as
const CATEGORIAS = {
    PERSONAJES: "personajes",
    ANIMALES: "animales", 
    OBJETOS: "objetos",
    PAISES: "paises",
    FAMOSOS: "famosos",
    PERSONAJES_ANIME: "personajes_anime",
    VIDEOJUEGOS: "videojuegos"
};

// Opciones de respuesta aceptadas
const RESPUESTAS = {
    SI: ["si", "s√≠", "yes", "s", "true", "verdadero", "1"],
    NO: ["no", "n", "false", "falso", "0"],
    TAL_VEZ: ["tal vez", "talvez", "quizas", "quiz√°", "quiz√°s", "puede ser", "maybe"],
    PROBABLEMENTE: ["probablemente", "casi seguro", "muy probable", "probably"],
    PROBABLEMENTE_NO: ["probablemente no", "casi seguro que no", "probably not"],
    DEPENDE: ["depende", "a veces", "en ocasiones", "depends"],
    DESCONOZCO: ["desconozco", "no s√©", "no se", "no lo s√©", "no lo se", "ni idea", "don't know", "no idea"]
};

// Funci√≥n para limpiar las preguntas y asegurar que est√°n en espa√±ol
function limpiarPregunta(pregunta) {
    if (!pregunta) return "¬øQu√© est√°s pensando?";
    
    // Quitar formato tipo "/question/" o similares
    pregunta = pregunta.replace(/\/(question|pregunta|query)\/\s*/gi, '');
    
    // Asegurar que empieza con un signo de interrogaci√≥n si no lo tiene
    if (!pregunta.includes("?") && !pregunta.includes("¬ø")) {
        pregunta = "¬ø" + pregunta + "?";
    }
    
    // Traducci√≥n simple de palabras comunes ingl√©s-espa√±ol si parece estar en ingl√©s
    const palabrasIngles = [
        {en: "is", es: "es"},
        {en: "are", es: "es/son"},
        {en: "does", es: "hace"},
        {en: "do", es: "hace"},
        {en: "can", es: "puede"},
        {en: "has", es: "tiene"},
        {en: "have", es: "tiene"},
        {en: "your", es: "tu"},
        {en: "the", es: "el/la"},
        {en: "a", es: "un/una"},
        {en: "you", es: "t√∫"},
        {en: "they", es: "ellos"},
        {en: "he", es: "√©l"},
        {en: "she", es: "ella"},
        {en: "it", es: "esto"},
        {en: "this", es: "este/esta"},
        {en: "that", es: "ese/esa"},
        {en: "with", es: "con"},
        {en: "for", es: "para"},
        {en: "from", es: "de"},
        {en: "at", es: "en"},
        {en: "by", es: "por"},
        {en: "on", es: "en"},
        {en: "in", es: "en"},
        {en: "to", es: "a"},
        {en: "of", es: "de"}
    ];
    
    // Detectar si parece estar en ingl√©s (aproximado)
    const palabrasDeteccion = ["is", "are", "does", "do", "the", "this", "that", "with", "for"];
    const preguntaLower = pregunta.toLowerCase();
    
    // Contamos cu√°ntas palabras detectadas en ingl√©s hay
    let contadorIngles = 0;
    
    for (const palabra of palabrasDeteccion) {
        const regex = new RegExp(`\\b${palabra}\\b`, 'i');
        if (regex.test(preguntaLower)) {
            contadorIngles++;
        }
    }
    
    // Si hay 2 o m√°s coincidencias, probable ingl√©s, intentamos traducir
    if (contadorIngles >= 2) {
        // Traducci√≥n simple palabra por palabra
        let preguntaTraducida = pregunta;
        
        for (const {en, es} of palabrasIngles) {
            const regex = new RegExp(`\\b${en}\\b`, 'gi');
            preguntaTraducida = preguntaTraducida.replace(regex, es);
        }
        
        return "¬ø" + preguntaTraducida.replace(/[¬ø?]/g, '').trim() + "?";
    }
    
    return pregunta;
}

// Funci√≥n para obtener decoraci√≥n tem√°tica seg√∫n categor√≠a
function obtenerTematicaCategoria(categoria) {
    const tematicas = {
        personajes: { emoji: "üë§", color: "#4CAF50", icono: "user" },
        animales: { emoji: "üêæ", color: "#FF9800", icono: "paw" },
        objetos: { emoji: "üîç", color: "#2196F3", icono: "search" },
        paises: { emoji: "üåé", color: "#3F51B5", icono: "globe" },
        famosos: { emoji: "üåü", color: "#E91E63", icono: "star" },
        personajes_anime: { emoji: "üéå", color: "#9C27B0", icono: "tv" },
        videojuegos: { emoji: "üéÆ", color: "#607D8B", icono: "gamepad" }
    };
    
    return tematicas[categoria.toLowerCase()] || { emoji: "üé≤", color: "#795548", icono: "question" };
}

// Traducir respuesta del usuario a un valor normalizado
function normalizarRespuesta(respuestaUsuario) {
    if (!respuestaUsuario) return null;
    
    const respuesta = respuestaUsuario.toLowerCase().trim();
    
    for (const [tipo, opciones] of Object.entries(RESPUESTAS)) {
        if (opciones.includes(respuesta)) {
            return tipo;
        }
    }
    
    // Si no coincide con ninguna respuesta conocida, intentar encontrar la m√°s cercana
    if (respuesta.includes("si") || respuesta.includes("s√≠")) return "SI";
    if (respuesta.includes("no")) return "NO";
    if (respuesta.includes("tal") || respuesta.includes("quiz")) return "TAL_VEZ";
    if (respuesta.includes("probab") && !respuesta.includes("no")) return "PROBABLEMENTE";
    if (respuesta.includes("probab") && respuesta.includes("no")) return "PROBABLEMENTE_NO";
    if (respuesta.includes("depend") || respuesta.includes("veces")) return "DEPENDE";
    if (respuesta.includes("conozco") || respuesta.includes("idea") || respuesta.includes("s√©")) return "DESCONOZCO";
    
    return "DESCONOCIDO";
}

// Endpoint principal para interactuar con el juego
router.get("/", async (req, res) => {
    try {
        const { 
            partidaId, 
            respuesta, 
            categoria = CATEGORIAS.PERSONAJES,
            reiniciar,
            formato = "json"
        } = req.query;

        // Validar categor√≠a
        if (!Object.values(CATEGORIAS).includes(categoria.toLowerCase())) {
            return res.status(400).json({
                "error": "Categor√≠a no v√°lida",
                "categorias_disponibles": Object.values(CATEGORIAS)
            });
        }

        // Verificar si se solicita reiniciar una partida
        if (partidaId && reiniciar === "true") {
            return await reiniciarPartida(partidaId, categoria, res);
        }

        // Si no hay partidaId, iniciar nueva partida
        if (!partidaId) {
            return await iniciarNuevaPartida(categoria, formato, res);
        }

        // Validar que la partida exista
        const partida = partidasActivas[partidaId];
        if (!partida) {
            return res.status(404).json({
                "error": "‚ùå Partida no encontrada",
                "sugerencia": "Inicia una nueva partida",
                "codigo_error": "PARTIDA_NO_ENCONTRADA"
            });
        }

        // Si ya se adivin√≥ o se ha llegado al l√≠mite, mostrar resultado
        if (partida.terminada) {
            return res.json({
                "partidaId": partidaId,
                "terminada": true,
                "personaje": partida.personaje,
                "mensaje": partida.mensajeFinal || "La partida ha terminado",
                "imagen": partida.imagenPersonaje,
                "estadisticas": {
                    "preguntas_totales": partida.preguntasHechas || 0,
                    "tiempo_juego": obtenerTiempoTranscurrido(partida.fechaCreacion)
                }
            });
        }

        // Verificar si la partida ha sido cancelada por inactividad
        if (partida.cancelada) {
            return res.json({
                "üéÆ": "Akinator API",
                "üÜî": partidaId,
                "‚ùó": "Partida cancelada por inactividad",
                "error": true,
                "mensaje": "‚è±Ô∏è La partida fue cancelada por exceder el tiempo de espera (30 segundos)",
                "sugerencia": "Puedes reiniciar la partida",
                "restart_url": `/api/fun/akinator?partidaId=${partidaId}&reiniciar=true`
            });
        }
        
        // Procesar respuesta si se proporciona
        if (respuesta) {
            const respuestaNormalizada = normalizarRespuesta(respuesta);
            
            if (respuestaNormalizada === "DESCONOCIDO") {
                return res.status(400).json({
                    "error": "‚ùå Respuesta no reconocida",
                    "sugerencia": "Utiliza una de las siguientes opciones",
                    "opciones_validas": {
                        "‚úÖ": RESPUESTAS.SI[0],
                        "‚ùå": RESPUESTAS.NO[0],
                        "ü§î": RESPUESTAS.TAL_VEZ[0],
                        "üîÑ": RESPUESTAS.PROBABLEMENTE[0],
                        "‚ö†Ô∏è": RESPUESTAS.PROBABLEMENTE_NO[0],
                        "üîÄ": RESPUESTAS.DEPENDE[0],
                        "‚ùì": RESPUESTAS.DESCONOZCO[0]
                    },
                    "botones": [
                        { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
                        { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
                        { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
                        { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
                        { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
                    ]
                });
            }
            
            // Reiniciar temporizador de inactividad
            iniciarTemporizadorPartida(partidaId);
            
            return await procesarRespuesta(partidaId, respuestaNormalizada, formato, res);
        }

        // Reiniciar temporizador de inactividad
        iniciarTemporizadorPartida(partidaId);
        
        // Obtener tema visual seg√∫n categor√≠a
        const tematica = obtenerTematicaCategoria(partida.categoria);
        
        // Devolver la siguiente pregunta (si no hay respuesta)
        return res.json({
            "üéÆ": "Akinator API", // Nombre decorativo
            "üÜî": partidaId, // ID de partida
            "partidaId": partidaId,
            "‚ùì": partida.preguntaActual, // Pregunta actual con emoji
            "pregunta": partida.preguntaActual,
            "pregunta_numero": partida.preguntasHechas || a0,
            "progreso": `${partida.progreso}%`,
            "progreso_valor": partida.progreso,
            "preguntas_maximas": 30,
            "preguntas_restantes": 30 - partida.preguntasHechas,
            "categoria": partida.categoria,
            "tema": tematica,
            "tiempo_limite": "‚è±Ô∏è 30 segundos para responder",
            "opciones_respuesta": {
                "‚úÖ": "S√≠, es correcto",
                "‚ùå": "No",
                "ü§î": "Tal vez",
                "üîÑ": "Probablemente s√≠",
                "‚ö†Ô∏è": "Probablemente no",
                "üîÄ": "Depende",
                "‚ùì": "No lo s√©"
            },
            "botones": [
                { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
                { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
                { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
                { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
                { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
            ],
            "tiempo_transcurrido": obtenerTiempoTranscurrido(partida.fechaCreacion),
            "tiempo_restante": "30s",
            "next_url": `/api/fun/akinator?partidaId=${partidaId}&respuesta=`
        });

    } catch (error) {
        console.error("Error en la API de Akinator:", error);
        res.status(500).json({ 
            "error": "Error al procesar la solicitud",
            "detalle": error.message 
        });
    }
});

// Endpoint para obtener informaci√≥n de una partida espec√≠fica
router.get("/partida/:id", (req, res) => {
    const partidaId = req.params.id;
    
    if (!partidaId || !partidasActivas[partidaId]) {
        return res.status(404).json({
            "error": "‚ùå Partida no encontrada",
            "codigo_error": "PARTIDA_NO_ENCONTRADA"
        });
    }
    
    const partida = partidasActivas[partidaId];
    const tematica = obtenerTematicaCategoria(partida.categoria);
    
    return res.json({
        "üéÆ": "Akinator API", // Nombre decorativo
        "üÜî": partidaId, // ID de partida
        "partidaId": partidaId,
        "estado": partida.terminada ? "‚úÖ Terminada" : "‚è≥ Activa",
        "personaje": partida.terminada ? partida.personaje : null,
        "imagen": partida.terminada && partida.personaje ? partida.imagenPersonaje : null,
        "progreso": `${partida.progreso}%`,
        "progreso_valor": partida.progreso,
        "categoria": partida.categoria,
        "tema": tematica,
        "‚ùì": partida.preguntaActual,
        "pregunta_actual": partida.preguntaActual,
        "preguntas_hechas": partida.preguntasHechas || 0,
        "preguntas_maximas": 30,
        "preguntas_restantes": 30 - partida.preguntasHechas,
        "tiempo_transcurrido": obtenerTiempoTranscurrido(partida.fechaCreacion),
        "fecha_creacion": partida.fechaCreacion,
        "tiempo_limite": partida.cancelada ? "‚åõ Tiempo excedido" : "‚è±Ô∏è 30 segundos para responder",
        "historial": partida.historial || [],
        "botones": [
            { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
            { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
            { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
            { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
            { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
        ],
        "next_url": partida.terminada ? 
            `/api/fun/akinator?partidaId=${partidaId}&reiniciar=true` : 
            `/api/fun/akinator?partidaId=${partidaId}&respuesta=`
    });
});

// Iniciar nueva partida
async function iniciarNuevaPartida(categoria, formato, res) {
    try {
        // Obtener pregunta inicial desde la IA
        const respuestaIA = await consultarDeepSeek(`
        Eres un juego de adivinanzas tipo Akinator.
        
        Genera una pregunta inicial para adivinar un ${categoria}.
        IMPORTANTE: RESPONDE SIEMPRE EN ESPA√ëOL con una pregunta clara y directa.
        
        Formato de respuesta:
        {
            "pregunta": "La pregunta inicial EN ESPA√ëOL (sin formato tipo '/question/')",
            "contexto": "Detalles adicionales que ayuden a entender la pregunta"
        }
        `);

        // Generar ID √∫nico para la partida
        const nuevoId = uuidv4();
        
        // Limpiar y verificar la pregunta (asegurar espa√±ol)
        const preguntaLimpia = limpiarPregunta(respuestaIA.pregunta);
        
        // Crear nueva partida con decoraci√≥n y metadatos adicionales
        partidasActivas[nuevoId] = {
            id: nuevoId,
            categoria: categoria,
            preguntaActual: preguntaLimpia,
            contexto: respuestaIA.contexto,
            progreso: 0,
            pistas: [],
            terminada: false,
            personaje: null,
            personajeProvisional: null,
            imagenPersonaje: null,
            fechaCreacion: new Date().toISOString(),
            ultimaInteraccion: new Date().toISOString(),
            preguntasHechas: 0,
            cancelada: false,
            confianza: 0,
            historial: [{
                pregunta: preguntaLimpia,
                respuesta: null,
                timestamp: new Date().toISOString()
            }],
            tematica: obtenerTematicaCategoria(categoria)
        };
        
        // Iniciar temporizador de inactividad
        iniciarTemporizadorPartida(nuevoId);

        // Si formato simple, respuesta m√≠nima
        if (formato === 'simple') {
            return res.json({
                "partidaId": nuevoId,
                "pregunta": preguntaLimpia,
                "categoria": categoria,
                "preguntas_maximas": 30
            });
        }
        
        // Respuesta est√°ndar con todos los detalles y decoraci√≥n
        return res.json({
            "üéÆ": "Akinator API", // Nombre decorativo
            "üÜî": nuevoId, // ID de partida
            "partidaId": nuevoId,
            "‚ùì": preguntaLimpia, // Pregunta actual con emoji
            "pregunta": preguntaLimpia,
            "contexto": respuestaIA.contexto,
            "progreso": 0,
            "pregunta_numero": 0,
            "preguntas_maximas": 30,
            "preguntas_restantes": 30,
            "categoria": categoria,
            "tema": obtenerTematicaCategoria(categoria),
            "tiempo_limite": "‚è±Ô∏è 30 segundos para responder",
            "opciones_respuesta": {
                "‚úÖ": "S√≠, es correcto",
                "‚ùå": "No",
                "ü§î": "Tal vez",
                "üîÑ": "Probablemente s√≠",
                "‚ö†Ô∏è": "Probablemente no",
                "üîÄ": "Depende",
                "‚ùì": "No lo s√©"
            },
            "botones": [
                { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
                { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
                { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
                { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
                { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
            ],
            "next_url": `/api/fun/akinator?partidaId=${nuevoId}&respuesta=`
        });

    } catch (error) {
        console.error("Error iniciando partida:", error);
        res.status(500).json({ 
            "error": "Error al iniciar la partida",
            "detalle": error.message 
        });
    }
}

// Reiniciar una partida existente
async function reiniciarPartida(partidaId, categoria, res) {
    // Verificar si la partida existe
    if (!partidasActivas[partidaId]) {
        return res.status(404).json({
            "error": "‚ùå Partida no encontrada para reiniciar",
            "sugerencia": "Inicia una nueva partida"
        });
    }
    
    // Usar la misma categor√≠a si no se especifica una nueva
    const categoriaFinal = categoria || partidasActivas[partidaId].categoria;
    
    // Limpiar temporizador asociado si existe
    if (temporizadoresPartidas[partidaId]) {
        clearTimeout(temporizadoresPartidas[partidaId]);
        delete temporizadoresPartidas[partidaId];
    }
    
    // Eliminar la partida anterior
    delete partidasActivas[partidaId];
    
    // Iniciar una nueva partida con el mismo ID
    try {
        // Obtener pregunta inicial desde la IA
        const respuestaIA = await consultarDeepSeek(`
        Eres un juego de adivinanzas tipo Akinator.
        
        Genera una pregunta inicial para adivinar un ${categoriaFinal}.
        IMPORTANTE: RESPONDE SIEMPRE EN ESPA√ëOL con una pregunta clara y directa.
        
        Formato de respuesta:
        {
            "pregunta": "La pregunta inicial EN ESPA√ëOL (sin formato tipo '/question/')",
            "contexto": "Detalles adicionales que ayuden a entender la pregunta"
        }
        `);
        
        // Limpiar y verificar la pregunta (asegurar espa√±ol)
        const preguntaLimpia = limpiarPregunta(respuestaIA.pregunta);
        
        // Crear nueva partida con el mismo ID
        partidasActivas[partidaId] = {
            id: partidaId,
            categoria: categoriaFinal,
            preguntaActual: preguntaLimpia,
            contexto: respuestaIA.contexto,
            progreso: 0,
            pistas: [],
            terminada: false,
            personaje: null,
            personajeProvisional: null,
            imagenPersonaje: null,
            fechaCreacion: new Date().toISOString(),
            ultimaInteraccion: new Date().toISOString(),
            preguntasHechas: 0,
            cancelada: false,
            confianza: 0,
            historial: [{
                pregunta: preguntaLimpia,
                respuesta: null,
                timestamp: new Date().toISOString()
            }],
            tematica: obtenerTematicaCategoria(categoriaFinal)
        };
        
        // Iniciar temporizador de inactividad
        iniciarTemporizadorPartida(partidaId);
        
        // Responder
        return res.json({
            "üéÆ": "Akinator API", // Nombre decorativo
            "üÜî": partidaId, // ID de partida
            "partidaId": partidaId,
            "mensaje": "Partida reiniciada correctamente",
            "pregunta": preguntaLimpia,
            "contexto": respuestaIA.contexto,
            "progreso": 0,
            "preguntas_maximas": 30,
            "preguntas_restantes": 30,
            "categoria": categoriaFinal,
            "opciones_respuesta": {
                "‚úÖ": "S√≠, es correcto",
                "‚ùå": "No",
                "ü§î": "Tal vez",
                "üîÑ": "Probablemente s√≠",
                "‚ö†Ô∏è": "Probablemente no",
                "üîÄ": "Depende",
                "‚ùì": "No lo s√©"
            },
            "botones": [
                { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
                { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
                { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
                { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
                { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
            ],
            "next_url": `/api/fun/akinator?partidaId=${partidaId}&respuesta=`
        });
        
    } catch (error) {
        console.error("Error reiniciando partida:", error);
        res.status(500).json({ 
            "error": "Error al reiniciar la partida",
            "detalle": error.message 
        });
    }
}

// Procesar respuesta del jugador
async function procesarRespuesta(partidaId, respuesta, formato, res) {
    const partida = partidasActivas[partidaId];
    
    // Incrementar contador de preguntas
    partida.preguntasHechas = (partida.preguntasHechas || 0) + 1;
    
    // Verificar si se alcanz√≥ el l√≠mite m√°ximo de preguntas (30)
    if (partida.preguntasHechas >= 30) {
        partida.terminada = true;
        
        // Si hay alg√∫n personaje provisional, usarlo como respuesta final
        if (partida.personajeProvisional) {
            partida.personaje = partida.personajeProvisional;
            partida.mensajeFinal = `ü§î Despu√©s de ${partida.preguntasHechas} preguntas, mi mejor suposici√≥n es: ${partida.personajeProvisional}`;
            
            // Buscar imagen del personaje
            try {
                const imagenInfo = await buscarImagenPersonaje(partida.personajeProvisional);
                partida.imagenPersonaje = imagenInfo;
            } catch (error) {
                console.error("Error buscando imagen:", error);
            }
        } else {
            partida.mensajeFinal = "üîç He llegado al l√≠mite de 30 preguntas y no he podido adivinar. ¬°Has ganado esta vez!";
        }
        
        // Liberar el temporizador
        if (temporizadoresPartidas[partidaId]) {
            clearTimeout(temporizadoresPartidas[partidaId]);
            delete temporizadoresPartidas[partidaId];
        }
        
        // Devolver resultado final
        return devolverResultadoFinal(partidaId, formato, res);
    }
    
    // Guardar la respuesta en el historial
    if (partida.historial && partida.historial.length > 0) {
        // Actualizar la √∫ltima entrada con la respuesta
        partida.historial[partida.historial.length - 1].respuesta = respuesta;
    }
    
    // Construir el prompt para la IA teniendo en cuenta m√°s tipos de respuestas
    let descripcionRespuesta;
    let emojiRespuesta;
    
    switch(respuesta) {
        case "SI": 
            descripcionRespuesta = "S√≠, es correcto";
            emojiRespuesta = "‚úÖ";
            break;
        case "NO": 
            descripcionRespuesta = "No";
            emojiRespuesta = "‚ùå";
            break;
        case "TAL_VEZ": 
            descripcionRespuesta = "Tal vez, no estoy seguro";
            emojiRespuesta = "ü§î";
            break;
        case "PROBABLEMENTE": 
            descripcionRespuesta = "Probablemente s√≠";
            emojiRespuesta = "üîÑ";
            break;
        case "PROBABLEMENTE_NO": 
            descripcionRespuesta = "Probablemente no";
            emojiRespuesta = "‚ö†Ô∏è";
            break;
        case "DEPENDE": 
            descripcionRespuesta = "Depende, no siempre";
            emojiRespuesta = "üîÄ";
            break;
        case "DESCONOZCO": 
            descripcionRespuesta = "No lo s√©, desconozco esa informaci√≥n";
            emojiRespuesta = "‚ùì";
            break;
        default:
            descripcionRespuesta = respuesta;
            emojiRespuesta = "üîç";
    }
    
    // Actualizar √∫ltima interacci√≥n para el tiempo de espera
    partida.ultimaInteraccion = new Date().toISOString();
    
    // Consultar a la IA para procesar la respuesta y generar nueva pregunta
    const respuestaIA = await consultarDeepSeek(`
    Est√°s jugando Akinator para adivinar un ${partida.categoria}.
    
    Contexto actual: ${partida.contexto || 'Sin contexto previo'}
    √öltima pregunta: ${partida.preguntaActual}
    Respuesta del jugador: ${descripcionRespuesta}
    N√∫mero de preguntas realizadas: ${partida.preguntasHechas}
    Preguntas restantes: ${30 - partida.preguntasHechas}
    
    IMPORTANTE: RESPONDE SIEMPRE EN ESPA√ëOL.
    
    Genera la siguiente pregunta, actualizando tu conocimiento seg√∫n la respuesta. La pregunta debe ser clara y directa.
    
    Formato de respuesta:
    {
        "pregunta": "Nueva pregunta para seguir adivinando (EN ESPA√ëOL, sin formato tipo '/pregunta/')",
        "contexto": "Informaci√≥n actualizada basada en la respuesta",
        "progresoAdivinanza": 0-100,
        "probabilidadAdivinanza": true/false,
        "personajeProvisional": "Si crees que ya sabes qu√© es, ponlo aqu√≠, sino null",
        "confianza": 0-100,
        "mensajeFinal": "Si tienes un personaje con alta confianza, a√±ade un mensaje final",
        "descripcion": "Breve descripci√≥n del personaje si lo has adivinado"
    }
    `);

    // Actualizar estado de la partida
    partida.preguntaActual = limpiarPregunta(respuestaIA.pregunta);
    partida.contexto = respuestaIA.contexto;
    partida.progreso = respuestaIA.progresoAdivinanza || Math.min(100, partida.progreso + 5);
    partida.ultimaInteraccion = new Date().toISOString();
    partida.confianza = respuestaIA.confianza || 0;
    partida.personajeProvisional = respuestaIA.personajeProvisional || partida.personajeProvisional;
    
    // A√±adir la nueva pregunta al historial
    partida.historial.push({
        pregunta: partida.preguntaActual,
        respuesta: null,
        timestamp: new Date().toISOString()
    });
    
    // Ver si la IA cree que ya puede adivinar
    const confianza = respuestaIA.confianza || 0;
    const umbralConfianza = 85; // Umbral alto para evitar adivinanzas incorrectas
    
    // Verificar si ya podemos adivinar el personaje
    if (respuestaIA.probabilidadAdivinanza && confianza >= umbralConfianza) {
        // Guardar el personaje y marcar como terminada
        partida.terminada = true;
        partida.personaje = respuestaIA.personajeProvisional;
        partida.mensajeFinal = respuestaIA.mensajeFinal || `‚ú® ¬°Creo que es ${respuestaIA.personajeProvisional}!`;
        partida.descripcionPersonaje = respuestaIA.descripcion || `Un ${partida.categoria}`;
        
        // Buscar una imagen del personaje
        try {
            const imagenInfo = await buscarImagenPersonaje(respuestaIA.personajeProvisional);
            partida.imagenPersonaje = imagenInfo;
        } catch (error) {
            console.error("Error buscando imagen:", error);
            partida.imagenPersonaje = {
                personaje: respuestaIA.personajeProvisional,
                searchUrl: `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(respuestaIA.personajeProvisional)}`
            };
        }
        
        // Liberar el temporizador
        if (temporizadoresPartidas[partidaId]) {
            clearTimeout(temporizadoresPartidas[partidaId]);
            delete temporizadoresPartidas[partidaId];
        }
        
        return devolverResultadoFinal(partidaId, formato, res);
    }
    
    // Si formato simple, respuesta m√≠nima
    if (formato === 'simple') {
        const respuesta = {
            "partidaId": partidaId,
            "pregunta": partida.preguntaActual,
            "terminada": partida.terminada,
            "personaje": partida.terminada ? partida.personaje : null,
            "mensaje": partida.terminada ? partida.mensajeFinal : null,
            "preguntas_realizadas": partida.preguntasHechas,
            "preguntas_maximas": 30
        };
        
        // Si terminada y hay personaje, incluir imagen
        if (partida.terminada && partida.personaje && partida.imagenPersonaje) {
            respuesta.imagen = partida.imagenPersonaje;
        }
        
        return res.json(respuesta);
    }
    
    // Obtener tema visual seg√∫n categor√≠a
    const tematica = obtenerTematicaCategoria(partida.categoria);
    
    // Construir respuesta con decoraci√≥n seg√∫n si termin√≥ o no
    if (partida.terminada) {
        return devolverResultadoFinal(partidaId, formato, res);
    } else {
        // Respuesta cuando a√∫n est√° en curso
        return res.json({
            "üéÆ": "Akinator API", // Nombre decorativo
            "üÜî": partidaId, // ID de partida
            "partidaId": partidaId,
            "‚ùì": respuestaIA.pregunta, // Pregunta actual con emoji
            "pregunta": partida.preguntaActual,
            "contexto": respuestaIA.contexto,
            "progreso": `${partida.progreso}%`,
            "progreso_valor": partida.progreso,
            "pregunta_numero": partida.preguntasHechas,
            "preguntas_restantes": 30 - partida.preguntasHechas,
            "preguntas_maximas": 30,
            "categoria": partida.categoria,
            "tema": tematica,
            "terminada": false,
            "tiempo_limite": "‚è±Ô∏è 30 segundos para responder",
            "tiempo_transcurrido": obtenerTiempoTranscurrido(partida.fechaCreacion),
            "opciones_respuesta": {
                "‚úÖ": "S√≠, es correcto",
                "‚ùå": "No",
                "ü§î": "Tal vez",
                "üîÑ": "Probablemente s√≠",
                "‚ö†Ô∏è": "Probablemente no",
                "üîÄ": "Depende",
                "‚ùì": "No lo s√©"
            },
            "botones": [
                { "valor": "si", "texto": "‚úÖ S√≠", "color": "#4CAF50" },
                { "valor": "no", "texto": "‚ùå No", "color": "#F44336" },
                { "valor": "tal_vez", "texto": "ü§î Tal vez", "color": "#2196F3" },
                { "valor": "probablemente", "texto": "üîÑ Probablemente", "color": "#FF9800" },
                { "valor": "desconozco", "texto": "‚ùì No lo s√©", "color": "#9E9E9E" }
            ],
            "next_url": `/api/fun/akinator?partidaId=${partidaId}&respuesta=`
        });
    }
}

// Funci√≥n para devolver el resultado final cuando se adivina o termina
function devolverResultadoFinal(partidaId, formato, res) {
    const partida = partidasActivas[partidaId];
    
    // Si formato simple, respuesta m√≠nima
    if (formato === 'simple') {
        const respuesta = {
            "partidaId": partidaId,
            "terminada": true,
            "personaje": partida.personaje,
            "mensaje": partida.mensajeFinal
        };
        
        // Si terminada y hay personaje, incluir imagen
        if (partida.personaje && partida.imagenPersonaje) {
            respuesta.imagen = partida.imagenPersonaje;
        }
        
        return res.json(respuesta);
    }
    
    // Obtener tema visual seg√∫n categor√≠a
    const tematica = obtenerTematicaCategoria(partida.categoria);
    
    // Respuesta cuando ha terminado (adivinado o cancelado)
    return res.json({
        "üéÆ": "Akinator API", // Nombre decorativo
        "üÜî": partidaId, // ID de partida
        "partidaId": partidaId,
        "estado": "‚úÖ ¬°Adivinado!",
        "terminada": true,
        "‚ú®": partida.personaje,
        "personaje": partida.personaje,
        "mensaje": partida.mensajeFinal,
        "imagen": partida.imagenPersonaje,
        "descripcion": partida.descripcionPersonaje || `Un ${partida.categoria}`,
        "confianza": `${partida.confianza}%`,
        "progreso": `100%`,
        "pregunta_numero": partida.preguntasHechas,
        "preguntas_maximas": 30,
        "categoria": partida.categoria,
        "tema": tematica,
        "tiempo_transcurrido": obtenerTiempoTranscurrido(partida.fechaCreacion),
        "estadisticas": {
            "preguntas_realizadas": partida.preguntasHechas,
            "tiempo_total": obtenerTiempoTranscurrido(partida.fechaCreacion),
            "fecha_inicio": partida.fechaCreacion,
            "fecha_fin": new Date().toISOString()
        },
        "acciones": {
            "reiniciar": `/api/fun/akinator?partidaId=${partidaId}&reiniciar=true`,
            "nueva_partida": "/api/fun/akinator"
        }
    });
}

// Funci√≥n para buscar una imagen del personaje
async function buscarImagenPersonaje(personaje) {
    try {
        // Construir URL de b√∫squeda de Google Images
        const searchQuery = encodeURIComponent(`${personaje} personaje`);
        
        // Opci√≥n 1: Devolver URL para que cliente realice la b√∫squeda
        const searchUrl = `https://www.google.com/search?tbm=isch&q=${searchQuery}`;
        
        // Opci√≥n 2: Intentar obtener una imagen directamente (mock)
        // Aqu√≠ podr√≠as implementar una b√∫squeda real con una API como Google Custom Search,
        // Bing Image Search o similar. Por ahora usaremos un enfoque simplificado.
        const imageUrl = `https://via.placeholder.com/300x300?text=${encodeURIComponent(personaje)}`;
        
        return {
            searchUrl: searchUrl,
            imageUrl: imageUrl,
            personaje: personaje
        };
    } catch (error) {
        console.error("Error buscando imagen:", error);
        return {
            searchUrl: `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(personaje)}`,
            error: "No se pudo obtener una imagen directa"
        };
    }
}

// Funci√≥n para manejar el tiempo de espera de una partida
function iniciarTemporizadorPartida(partidaId) {
    // Cancelar temporizador anterior si existe
    if (temporizadoresPartidas[partidaId]) {
        clearTimeout(temporizadoresPartidas[partidaId]);
    }
    
    // Crear nuevo temporizador (30 segundos)
    temporizadoresPartidas[partidaId] = setTimeout(() => {
        // Verificar si la partida a√∫n existe
        if (partidasActivas[partidaId]) {
            // Marcar como cancelada por inactividad
            partidasActivas[partidaId].cancelada = true;
            partidasActivas[partidaId].mensajeFinal = "‚ú® Partida cancelada por inactividad (30 segundos sin respuesta)";
            partidasActivas[partidaId].terminada = true;
            
            console.log(`‚è±Ô∏è Partida ${partidaId} cancelada por tiempo de espera excedido`);
        }
        
        // Eliminar referencia al temporizador
        delete temporizadoresPartidas[partidaId];
    }, 30000); // 30 segundos
}

// Funci√≥n para calcular el tiempo transcurrido
function obtenerTiempoTranscurrido(fechaInicio) {
    const inicio = new Date(fechaInicio).getTime();
    const ahora = Date.now();
    const diferenciaMs = ahora - inicio;
    
    const segundos = Math.floor(diferenciaMs / 1000);
    const minutos = Math.floor(segundos / 60);
    const horas = Math.floor(minutos / 60);
    
    if (horas > 0) {
        return `${horas}h ${minutos % 60}m`;
    } else if (minutos > 0) {
        return `${minutos}m ${segundos % 60}s`;
    } else {
        return `${segundos}s`;
    }
}

// Consultar a DeepSeek
async function consultarDeepSeek(prompt) {
    try {
        const response = await axios.get(`http://api.apikarl.com/api/utility/deepseek`, {
            params: { prompt }
        });
        
        if (!response.data || !response.data.respuesta) {
            throw new Error("Respuesta inv√°lida de DeepSeek");
        }
        
        // Intentar parsear la respuesta JSON
        try {
            return JSON.parse(response.data.respuesta);
        } catch (parseError) {
            console.error("Error al parsear respuesta JSON:", parseError);
            
            // Si falla el parseo, aplicar un regex para extraer JSON
            const jsonMatch = response.data.respuesta.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    return JSON.parse(jsonMatch[0]);
                } catch (secondParseError) {
                    console.error("Error en segundo intento de parsing:", secondParseError);
                }
            }
            
            // Si todo falla, devolver un objeto con la pregunta directamente
            return { 
                pregunta: response.data.respuesta, 
                contexto: "Respuesta no estructurada",
                progresoAdivinanza: 10
            };
        }
    } catch (error) {
        console.error("Error consultando DeepSeek:", error);
        throw error;
    }
}

// Endpoint de info (versi√≥n mejorada)
router.get("/info", (req, res) => {
    const estadisticas = {
        partidas_activas: Object.keys(partidasActivas).length,
        partidas_por_categoria: {}
    };
    
    // Calcular estad√≠sticas por categor√≠a
    Object.values(partidasActivas).forEach(partida => {
        const categoria = partida.categoria;
        if (!estadisticas.partidas_por_categoria[categoria]) {
            estadisticas.partidas_por_categoria[categoria] = 0;
        }
        estadisticas.partidas_por_categoria[categoria]++;
    });
    
    res.json({
        "nombre": "Akinator API - Versi√≥n Mejorada",
        "descripcion": "Juego de adivinanzas con inteligencia artificial",
        "categorias": Object.values(CATEGORIAS),
        "opciones_respuesta": {
            "SI": RESPUESTAS.SI[0],
            "NO": RESPUESTAS.NO[0],
            "TAL_VEZ": RESPUESTAS.TAL_VEZ[0],
            "PROBABLEMENTE": RESPUESTAS.PROBABLEMENTE[0],
            "PROBABLEMENTE_NO": RESPUESTAS.PROBABLEMENTE_NO[0],
            "DEPENDE": RESPUESTAS.DEPENDE[0],
            "DESCONOZCO": RESPUESTAS.DESCONOZCO[0]
        },
        "preguntas_maximas": 30,
        "tiempo_limite": "30 segundos entre respuestas",
        "instrucciones": [
            "1. Inicia una partida: GET /api/fun/akinator?categoria=personajes",
            "2. Responde a las preguntas: GET /api/fun/akinator?partidaId=ID&respuesta=RESPUESTA",
            "3. Reinicia una partida: GET /api/fun/akinator?partidaId=ID&reiniciar=true",
            "4. Consulta estado de partida: GET /api/fun/akinator/partida/ID"
        ],
        "ejemplos": [
            "/api/fun/akinator?categoria=personajes_anime",
            "/api/fun/akinator?partidaId=abc123&respuesta=si",
            "/api/fun/akinator?partidaId=abc123&respuesta=tal vez",
            "/api/fun/akinator?formato=simple (para respuestas simplificadas)"
        ],
        "estadisticas": estadisticas
    });
});

// Endpoint para listar partidas activas (admin)
router.get("/admin/partidas", (req, res) => {
    // Aqu√≠ podr√≠as implementar autenticaci√≥n para administradores
    const { key } = req.query;
    
    if (key !== "admin_key_secreta") {
        return res.status(403).json({ "error": "No autorizado" });
    }
    
    const resumen = Object.entries(partidasActivas).map(([id, partida]) => ({
        id,
        categoria: partida.categoria,
        progreso: partida.progreso,
        terminada: partida.terminada,
        creacion: partida.fechaCreacion,
        preguntas: partida.preguntasHechas || 0,
        preguntas_restantes: 30 - (partida.preguntasHechas || 0)
    }));
    
    res.json({
        total_partidas: resumen.length,
        partidas: resumen
    });
});

// Limpiar partidas caducadas y temporizadores
setInterval(() => {
    const ahora = Date.now();
    const tiempoMaximo = 60 * 60 * 1000; // 1 hora (mayor tiempo de caducidad)
    let partidasEliminadas = 0;
    let temporizadoresLimpiados = 0;
    
    // Limpiar partidas inactivas
    Object.keys(partidasActivas).forEach(id => {
        const partida = partidasActivas[id];
        const ultimaInteraccion = new Date(partida.ultimaInteraccion || partida.fechaCreacion).getTime();
        const tiempoTranscurrido = ahora - ultimaInteraccion;
        
        if (tiempoTranscurrido > tiempoMaximo) {
            // Limpiar temporizador asociado si existe
            if (temporizadoresPartidas[id]) {
                clearTimeout(temporizadoresPartidas[id]);
                delete temporizadoresPartidas[id];
                temporizadoresLimpiados++;
            }
            
            // Eliminar partida
            delete partidasActivas[id];
            partidasEliminadas++;
        }
    });
    
    // Limpiar temporizadores hu√©rfanos (sin partida asociada)
    Object.keys(temporizadoresPartidas).forEach(id => {
        if (!partidasActivas[id]) {
            clearTimeout(temporizadoresPartidas[id]);
            delete temporizadoresPartidas[id];
            temporizadoresLimpiados++;
        }
    });
    
    if (partidasEliminadas > 0 || temporizadoresLimpiados > 0) {
        console.log(`üßπ Limpieza: ${partidasEliminadas} partidas y ${temporizadoresLimpiados} temporizadores eliminados por inactividad`);
    }
}, 10 * 60 * 1000); // Ejecutar cada 10 minutos

module.exports = router;
